\section{Sviluppo}
\subsection{Testing automatizzato}
Per effettuare i test necessari per i corretti controlli di funzionalità del nostro software abbiamo utilizzato la suite dedicata JUnit 5. I test che siamo andati ad implementare riguardano:
\begin{itemize}
    \item ControllerTest: //TODO//
    \item GameSetTest: questa classe permette di testare la corretta creazione di vari GameSet (esempio: citySet, FieldSet), l'unione di due GameSet, il piazzamento di meeple all'interno dei GameSet. Sono presenti test anche per il controllo della corretta assegnazione e modifica dei punti relativi ai GameSet, inclusa anche la gestione della corretta chiusura di un GameSet e dell'assegnazione dei punti ai player aventi meeples sul GameSet appena chiuso. 
    \item NormalMeepleTest: questa classe permette di testare i metodi appartenenti al NormalMeeple e il posizionamento di esso all'interno di una Tile.
    \item PlayerTest: questa classe ci permette di testare i metodi appartenenti al Player e la modifica progressiva dei punti assegnatogli.
    \item TileTest: questa classe ci permette di andar a testare la corretta creazione di tiles e i metodi ad essa associata, più in specifico la chiusura di una TileSection all'interno della Tile. Viene testato anche lo scorrimento circolare di una TileSection all'interno di una Tile.
    \item ToStringBuilderTest: questa classe ci permette di testare la classe ToStringBuilder, in particolar modo l'ottenimento di una stringa rappresentativa per un qualsiasi Object. Infine verifica la consistenza delle rappresentazioni letterali degli oggetti, garantendo che rimangano invariate.
    \item DirectionTest: questa classe ci permette di testare l'enum Direction e il suo metodo match che controlla se la differenza delle coordinate di due punti combacia con la direzione fornita
    \item GameSetTileMediatorTest: questa classe ci permette di testare i vari metodi della classe GameSetTileMediator, per esempio la rotazione di una Tila con i GameSet ad essa associata, e la corretta corrispondenza tra Tiles con le proprie TileSection e i GameSet.
\end{itemize}
Non sono stati creati test JUnit nella View poichè 

\subsection{Metodologia di lavoro}
Nelle prime ore dedicate al nostro progetto, abbiamo deciso e impostato l'architettura software da usare, l'MVC, successivamente abbiamo impostato e sviluppato le interfacce generiche che poi sarebbero state utilizzate come guida nello sviluppo software nelle singole parti di model, controller e view. Abbiamo utilizzato il software visto a lezione GitHub per la gestione e condivisione di software da noi creato e sviluppato individualmente.
\subsubsection*{Mauro Pellonara} 
In autonomia ho sviluppato:
\begin{itemize}
    \item 
\end{itemize}
In collaborazione ho sviluppato:
\begin{itemize}
    \item 
\end{itemize}

\subsubsection*{Alessandro Martini}
In autonomia ho sviluppato:
\begin{itemize}
    \item Implementazione e gestione dei vari GameSet (package it.unibo.caesena.model.gameset)
    \item Implementazione della GameOverScene (package it.unibo.caesena.view.scene)
    \item Implementazione Configuration Loader (package it.unibo.caesena.controller) 
    \item Controller.endTurn() (package it.unibo.caesena.controller)
    \item Controller.discardCurrentTile (package it.unibo.caesena.controller)
    \item Controller.isCurrentTilePlaceable (package it.unibo.caesena.controller)
    \item Controller.getEmptyNeighbouringPositions (package it.unibo.caesena.controller)
    \item Controller.isPositionOccupied (package it.unibo.caesena.controller)
\end{itemize}
In collaborazione ho sviluppato:
\begin{itemize}
    \item con Mauro Pellonara: 
    \begin{itemize}
        \item Controller.endGame() (package it.unibo.caesena controller)
    \end{itemize}
\end{itemize}

\subsubsection*{Davide Speziali}
In autonomia ho sviluppato:
\begin{itemize}
    \item 
\end{itemize}
In collaborazione ho sviluppato:
\begin{itemize}
    \item 
\end{itemize}

\subsubsection*{Samuele Giancarli}
In autonomia ho sviluppato:
\begin{itemize}
    \item Controller.placeCurrentTile (package it.unibo.caesena.controller)
    \item Controller.rotateCurrentTile (package it.unibo.caesena.controller)
    \item Implementazione del LeaderBoardComponent (it.unibo.caesena.view.components.player)
    \item Implementazione del SideBarComponent (it.unibo.caesena.view.components)
    \item Implementazione del RemainingMeeple RemainingMeepleComponent (it.unibo.caesena.view.components.meeple)
    \item Implementazione del ResourceUtil (it.unibo.caesena.utils)
    \item Inserimento delle Tessere PENNANT in TileType (it.unibo.caesena.model.tile)
    \item Implementazione delle Factory per le tessere PENNANT in TileFactoryWithBuilder (it.unibo.caesena.model.tile)
    %mettere a posto le questione placecurrent tile in quanto
    %la funzione ora è chiamata dal mediator ed il codice
    %è stato spostato.
    %la logica del place current tile oltre a verificare
    %che la posizione selezionata non fosse stata già piazzata
    %andava a verificare che esistesse almeno una tile neighbour
    %e per ogni tile neighbour che tutte le sue section adiacenti
    %con quelle della tile corrente fossero dello stesso tipo
\end{itemize}

In collaborazione ho sviluppato:
\begin{itemize}
    \item Tile in collaborazione con mauro pellonara
    \item Footer in collaborazione con mauro pellonara
\end{itemize}

\subsection{Note di sviluppo}
\subsubsection*{Mauro Pellonara} 

\subsubsection*{Alessandro Martini}
\begin{itemize}
    \item Utilizzo di Stream: sono presenti all'interno delle classi sviluppati porzioni di codice contenente il costrutto funzionale Stream: \url{https://github.com/MauroPello/OOP22-caesena/blob/2e7e1877928505c25e791d2e1ba6e5ebffffca64/src/main/java/it/unibo/caesena/model/gameset/GameSetImpl.java}
    \item Uso di JSON Parser: utilizzo di un JSON parser per prendere tutte le tile presenti nel gioco (memorizzate nel file config.json) \url{https://github.com/MauroPello/OOP22-caesena/blob/2e7e1877928505c25e791d2e1ba6e5ebffffca64/src/main/java/it/unibo/caesena/controller/ConfigurationLoader.java}
\end{itemize}

\subsubsection*{Davide Speziali}

\subsubsection*{Samuele Giancarli}
ecco cosa fa il getCurrentTile:

\begin{itemize}
\item va a verificare che la posizione selezionata non fosse stata già occupata da un’altra tessera, in caso negativo ritorna false
\item va a verificare che esista almeno una tile neighbour, in caso negativo ritorna false
\item va a verificare per ogni tile neighbour che la totalità delle section adiacenti alla current tile siano dello stesso tipo
\item solo dopo aver controllato ogni section di ogni neighbour e aver appurato che la current tile sia piazzabile allora: setPosition(position)
\item a questo punto ad ogni neighbour dovranno essere impostate a closed le section connesse con la current tile. La stessa cosa verrà fatta per le section della current tile connesse a quelle di un neighbour.
\subitem la struttura del ciclo è la stessa di quello precedente, ma è solo grazie al completamento del ciclo precedente che si avrà la sicurezza di poter impostare tutte le section a closed 
\item (??????) solo a questo punto sarà possibile unire i gameset della tile corrente con quelli delle tile già presenti
\end{itemize}