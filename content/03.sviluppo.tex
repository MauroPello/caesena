\section{Sviluppo}
\subsection{Testing automatizzato}
Per effettuare i test necessari per i corretti controlli di funzionalità del nostro software abbiamo utilizzato la suite dedicata JUnit 5. I test che siamo andati ad implementare riguardano:
\begin{itemize}
    \item ControllerTest: //TODO//
    \item GameSetTest: questa classe permette di testare la corretta creazione di vari GameSet (esempio: citySet, FieldSet), l'unione di due GameSet, il piazzamento di meeple all'interno dei GameSet. Sono presenti test anche per il controllo della corretta assegnazione e modifica dei punti relativi ai GameSet, inclusa anche la gestione della corretta chiusura di un GameSet e dell'assegnazione dei punti ai player aventi meeples sul GameSet appena chiuso.
    \item NormalMeepleTest: questa classe permette di testare i metodi appartenenti al NormalMeeple e il posizionamento di esso all'interno di una Tile.
    \item PlayerTest: questa classe ci permette di testare i metodi appartenenti al Player e la modifica progressiva dei punti assegnatogli.
    \item TileTest: questa classe ci permette di andar a testare la corretta creazione di tiles e i metodi ad essa associata, più in specifico la chiusura di una TileSection all'interno della Tile. Viene testato anche lo scorrimento circolare di una TileSection all'interno di una Tile.
    \item ToStringBuilderTest: questa classe ci permette di testare la classe ToStringBuilder, in particolar modo l'ottenimento di una stringa rappresentativa per un qualsiasi Object. Infine verifica la consistenza delle rappresentazioni letterali degli oggetti, garantendo che rimangano invariate.
    \item DirectionTest: questa classe ci permette di testare l'enum Direction e il suo metodo match che controlla se la differenza delle coordinate di due punti combacia con la direzione fornita
    \item GameSetTileMediatorTest: questa classe ci permette di testare i vari metodi della classe GameSetTileMediator, per esempio la rotazione di una Tila con i GameSet ad essa associata, e la corretta corrispondenza tra Tiles con le proprie TileSection e i GameSet.
\end{itemize}

Per quanto riguarda la parte di view non sono stati scritti dei veri e propri test JUnit, ma si è ritenuto più opportuno testare manualmente le funzionalità principali:
\begin{itemize}
    \item utilizzando schermi di diverse dimensioni e risoluzioni per verificare che il gioco funzionasse ugualmente per ognuno di essi ed il ridimensionamento fosse corretto.
    \item utilizzando variabili di debug per accedere direttamente ad una Scene da testare evitando la logica di gioco che avrebbe portato ad essa.
\end{itemize}

\subsection{Metodologia di lavoro}
Ci siamo focalizzati molto sulla fase di progettazione in modo da avere interfacce ben definite una volta iniziata la fase di sviluppo. Sempre in questa fase una parte che ha richiesto altrettanta attenzione è stata la ricerca di tecniche per effettuare una trasposizione informatica fedele al gioco da tavolo originale. Inizialmente abbiamo suddiviso il lavoro in modo che ognuno potesse lavorare parallelamente. Ci sono stati casi in cui è stato deciso, per efficienza e semplicità, che un componente del gruppo lavorasse su classi non di sua competenza, questo è avvenuto per due possibili ragioni:
\begin{itemize}
    \item Individuazione e risoluzione tempestiva e continuativa di bug o errori di sorta.
    \item Implentazioni di tecniche o pattern da applicare nel medesimo modo in più classi e interfacce.
\end{itemize}
Per quanto riguarda il DVCS abbiamo deciso di utilizzare Git, in particolare abbiamo creato due diversi branch, uno per la stesura della relazione e l'altro per lo sviluppo del codice. Ogni componente ha quindi avuto la resposabilità di clonare localmente la repository e di fare le operazioni di \textit{pull}, \textit{push} ed eventualmente \textit{merge}.
\subsubsection*{Mauro Pellonara}
In autonomia ho sviluppato:
\begin{itemize}
    \item
\end{itemize}
In collaborazione ho sviluppato:
\begin{itemize}
    \item
\end{itemize}

\subsubsection*{Alessandro Martini}
In autonomia ho sviluppato:
\begin{itemize}
    \item Implementazione e gestione dei vari GameSet (package it.unibo.caesena.model.gameset)
    \item Implementazione della GameOverScene (package it.unibo.caesena.view.scene)
    \item Implementazione Configuration Loader (package it.unibo.caesena.controller)
    \item Controller.endTurn() (package it.unibo.caesena.controller)
    \item Controller.discardCurrentTile (package it.unibo.caesena.controller)
    \item Controller.isCurrentTilePlaceable (package it.unibo.caesena.controller)
    \item Controller.getEmptyNeighbouringPositions (package it.unibo.caesena.controller)
    \item Controller.isPositionOccupied (package it.unibo.caesena.controller)
\end{itemize}
In collaborazione ho sviluppato:
\begin{itemize}
    \item con Mauro Pellonara:
    \begin{itemize}
        \item Controller.endGame() (package it.unibo.caesena controller)
    \end{itemize}
\end{itemize}

\subsubsection*{Davide Speziali}
In autonomia ho sviluppato:
\begin{itemize}
    \item
\end{itemize}
In collaborazione ho sviluppato:
\begin{itemize}
    \item
\end{itemize}

\subsubsection*{Samuele Giancarli}
In autonomia ho sviluppato:
\begin{itemize}
    \item Controller.placeCurrentTile (package it.unibo.caesena.controller)
    \item Controller.rotateCurrentTile (package it.unibo.caesena.controller)
    \item Implementazione del LeaderBoardComponent (it.unibo.caesena.view.components.player)
    \item Implementazione del SideBarComponent (it.unibo.caesena.view.components)
    \item Implementazione del RemainingMeeple RemainingMeepleComponent (it.unibo.caesena.view.components.meeple)
    \item Implementazione del ResourceUtil (it.unibo.caesena.utils)
    \item Inserimento delle Tessere PENNANT in TileType (it.unibo.caesena.model.tile)
    \item Implementazione delle Factory per le tessere PENNANT in TileFactoryWithBuilder (it.unibo.caesena.model.tile)
    %mettere a posto le questione placecurrent tile in quanto
    %la funzione ora è chiamata dal mediator ed il codice
    %è stato spostato.
    %la logica del place current tile oltre a verificare
    %che la posizione selezionata non fosse stata già piazzata
    %andava a verificare che esistesse almeno una tile neighbour
    %e per ogni tile neighbour che tutte le sue section adiacenti
    %con quelle della tile corrente fossero dello stesso tipo
\end{itemize}

In collaborazione ho sviluppato:
\begin{itemize}
    \item Tile in collaborazione con mauro pellonara
    \item Footer in collaborazione con mauro pellonara
\end{itemize}

\subsection{Note di sviluppo}
\subsubsection*{Mauro Pellonara}

\subsubsection*{Alessandro Martini}
\begin{itemize}
    \item Utilizzo di Stream: sono presenti all'interno delle classi sviluppati porzioni di codice contenente il costrutto funzionale Stream: \url{https://github.com/MauroPello/OOP22-caesena/blob/2e7e1877928505c25e791d2e1ba6e5ebffffca64/src/main/java/it/unibo/caesena/model/gameset/GameSetImpl.java}
    \item Uso di JSON Parser: utilizzo di un JSON parser per prendere tutte le tile presenti nel gioco (memorizzate nel file config.json) \url{https://github.com/MauroPello/OOP22-caesena/blob/2e7e1877928505c25e791d2e1ba6e5ebffffca64/src/main/java/it/unibo/caesena/controller/ConfigurationLoader.java}
\end{itemize}

\subsubsection*{Davide Speziali}

\subsubsection*{Samuele Giancarli}
ecco cosa fa il getCurrentTile:

\begin{itemize}
\item va a verificare che la posizione selezionata non fosse stata già occupata da un’altra tessera, in caso negativo ritorna false
\item va a verificare che esista almeno una tile neighbour, in caso negativo ritorna false
\item va a verificare per ogni tile neighbour che la totalità delle section adiacenti alla current tile siano dello stesso tipo
\item solo dopo aver controllato ogni section di ogni neighbour e aver appurato che la current tile sia piazzabile allora: setPosition(position)
\item a questo punto ad ogni neighbour dovranno essere impostate a closed le section connesse con la current tile. La stessa cosa verrà fatta per le section della current tile connesse a quelle di un neighbour.
\subitem la struttura del ciclo è la stessa di quello precedente, ma è solo grazie al completamento del ciclo precedente che si avrà la sicurezza di poter impostare tutte le section a closed
\item (??????) solo a questo punto sarà possibile unire i gameset della tile corrente con quelli delle tile già presenti
\end{itemize}